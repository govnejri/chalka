# Python Foundation Cheatsheet

Краткая выжимка базы. Если забыл синтаксис или поведение — смотри сюда.

## 1. Арифметика и Типы

Тут все просто, но есть нюансы с делением.

`x = 5`
`y = 2`

`print(x / y)` # `2.5` (обычное деление, всегда float)
`print(x // y)` # `2` (целочисленное деление)
`print(x % y)` # `1` (остаток от деления)
`print(x \*\* y)` # `25` (возведение в степень)

Нюанс `float`
`print(0.1 + 0.2)` # `0.30000000000000004` (погрешность дробей)

**Логика**
`True` и `False` пишутся с большой буквы.
`and`, `or`, `not` — словами, а не символами.

## 2. Строки (String)

Строки **неизменяемые**. Нельзя сделать `s[0] = 'a'`.

**Срезы (Slicing)**
Формат: `[start:stop:step]`
s = "Hello Python"
print(s[0:5]) # Hello (с 0 по 4, 5 не включается)
print(s[:5]) # Hello (начало можно опустить)
print(s[6:]) # Python (до конца)
print(s[::-1]) # nohtyP olleH (разворот строки)

text

**Методы**
s.lower() # нижний регистр
s.upper() # верхний регистр
s.strip() # убрать пробелы по бокам
s.split(',') # разбить строку в список по запятой
', '.join(list) # собрать список в строку через запятую
s.find('Py') # индекс первого вхождения (или -1)
s.replace('a', 'b') # заменить ВСЕ вхождения

text

## 3. Списки (List)

Списки **изменяемые**. Это контейнеры ссылок.

**База**
lst =​
lst.append(4) # добавить в конец:​
lst.insert(0, 9) # вставить 9 на позицию 0
lst.pop() # удалить и вернуть последний элемент

text

**Сортировка (Важно)**
a =​
b = sorted(a) # СОЗДАЕТ новый отсортированный список. a не меняется.
a.sort() # Сортирует a НА МЕСТЕ. Возвращает None.

text

**Генераторы списков (List Comprehension)**
Способ создавать списки в одну строку. Быстрее обычного цикла.
Квадраты четных чисел от 0 до 9
squares = [x**2 for x in range(10) if x % 2 == 0]

text

## 4. Память и Ссылки (Самое важное)

Переменная это не коробка, а стикер на объекте.

a =​
b = a # b ссылается на ТОТ ЖЕ объект, что и a
b.append(4)

print(a) # — a тоже изменилось!​

text

**Как копировать по-настоящему:**
b = a[:] # срез создает поверхностную копию
b = list(a) # тоже копия

text

## 5. Словари (Dict)

Ключ: Значение. Поиск по ключу мгновенный O(1).
Ключом может быть только **неизменяемый** тип (число, строка, кортеж). Список не может быть ключом.

d = {'name': 'Max', 'age': 25}

Получение
print(d['name']) # Max
print(d.get('job')) # None (безопасный метод, не падает ошибкой)
print(d.get('job', 'Dev')) # Dev (значение по умолчанию)

Перебор
for key, val in d.items():
print(key, val)

text

## 6. Циклы

**for**
Итерируемся по всему, что можно перебрать.
for i in range(5): # 0, 1, 2, 3, 4
pass

for x in: # По элементам списка​
pass

text

**while**
Пока условие истинно.
while True:
cmd = input()
if cmd == 'exit':
break # выход из цикла
if cmd == 'skip':
continue # пропуск итерации

text

## 7. Функции

def my_func(a, b=10): # b — аргумент по умолчанию
return a + b

text

**Ловушка аргумента по умолчанию**
Никогда не используй изменяемые типы (списки) как дефолтные значения.

ПЛОХО
def add_item(item, lst=[]):
lst.append(item)
return lst

ХОРОШО
def add_item(item, lst=None):
if lst is None:
lst = []
lst.append(item)
return lst

text

## 8. Файлы

Всегда используй контекстный менеджер `with`. Он сам закроет файл, даже если будет ошибка.

Чтение
with open('data.txt', 'r', encoding='utf-8') as f:
text = f.read() # считать все
lines = f.readlines() # считать списком строк

Запись (перезапишет файл!)
with open('out.txt', 'w') as f:
f.write('Hello')

Дозапись в конец
with open('log.txt', 'a') as f:
f.write('\nNew line')

text

## 9. Полезные встроенные функции

- `len(x)` — длина.
- `type(x)` — тип данных.
- `id(x)` — адрес в памяти.
- `input()` — всегда возвращает строку. Для чисел нужно `int(input())`.
- `min(seq)`, `max(seq)`, `sum(seq)` — статистика по списку.
- `enumerate(lst)` — дает и индекс, и значение в цикле:
  ```
  for idx, val in enumerate(['a', 'b']):
      print(idx, val) # 0 a, 1 b
  ```
